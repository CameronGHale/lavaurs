"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fractions_1 = require("./fractions");
const polygons_1 = require("./polygons");
const immutable_1 = require("immutable");
const distinct = (key) => {
    let set = new Set();
    return (item) => {
        const itemKey = key(item);
        const isNew = !set.has(itemKey);
        if (isNew) {
            set.add(itemKey);
        }
        return isNew;
    };
};
const removeDuplicates = () => distinct(poly => poly.toString());
function* iterates(leaves, branches) {
    let newLeaves = leaves;
    while (true) {
        yield newLeaves;
        newLeaves = pullBack((_, newPolygon) => newPolygon)(newLeaves, branches);
    }
}
const pullBack = (raise) => (leaves, branches) => {
    const result = [];
    for (const leaf of leaves) {
        const pulledBackPoints = leaf.points.flatMap(fractions_1.Fractions.mapBackward);
        let remainingIndices = immutable_1.Range(0, pulledBackPoints.size).toSet();
        for (const branch of branches) {
            const filtered = remainingIndices.toSeq()
                .map((idx) => [idx, pulledBackPoints.get(idx)])
                .filter(([_idx, point]) => branch.contains(point));
            remainingIndices = remainingIndices.subtract(filtered.map(([idx, _point]) => idx));
            const newPoints = filtered.map(([_idx, point]) => point).toList();
            if (newPoints.size === 0)
                continue;
            const nextPolygon = raise(leaf, polygons_1.Polygons.create(newPoints));
            result.push(nextPolygon);
        }
    }
    return result;
};
const mapForward = (innerMapForward) => (leaves) => leaves.map(innerMapForward).filter(removeDuplicates());
exports.Laminations = { iterates, pullBack, mapForward, removeDuplicates };
//# sourceMappingURL=lamination.js.map
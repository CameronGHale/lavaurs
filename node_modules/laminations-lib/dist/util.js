"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const immutable_1 = require("immutable");
exports.cache = (func) => () => {
    let result = null;
    if (result == null) {
        result = func();
    }
    return result;
};
exports.withCachedToString = (toString, item) => {
    return Object.assign(Object.assign({}, item), { toString: exports.cache(() => toString(item)) });
};
// ex: ([1,2,3], 1) -> [3,1,2]
exports.rotateRight = (list, offset) => {
    const len = list.size;
    if (exports.mod(offset, len) === 0) {
        return list;
    }
    if (offset === 1) {
        return list.withMutations(copy => {
            const last = copy.last();
            if (last == null)
                return;
            copy.pop().unshift(last);
        });
    }
    return immutable_1.List().setSize(len).withMutations(result => {
        for (let idx = 0; idx < len; idx++) {
            result.set(exports.mod(idx + offset, len), list.get(idx));
        }
    });
};
exports.rotateLeft = (list, offset) => {
    if (offset === 1) {
        return list.withMutations(copy => {
            const first = copy.first();
            if (first == null)
                return;
            copy.shift().push(first);
        });
    }
    return exports.rotateRight(list, -1 * offset);
};
exports.mod = (a, b) => ((a % b) + b) % b;
exports.greatestCommonDivisor = (b, a) => {
    if (a === 0) {
        return b;
    }
    return exports.greatestCommonDivisor(a, exports.mod(b, a));
};
exports.integer_pow = (base, exponent) => {
    let result = 1;
    if (exponent === 0) {
        return result;
    }
    let exp = exponent;
    let pow_i = base;
    while (exp > 0) {
        if ((exp & 1) !== 0) {
            result *= pow_i;
        }
        pow_i *= pow_i;
        exp >>= 1;
    }
    return result | 0;
};
exports.xor = (a, b) => a ? !b : b;
//# sourceMappingURL=util.js.map
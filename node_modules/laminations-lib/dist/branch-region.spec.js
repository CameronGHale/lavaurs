"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fractions_1 = require("./fractions");
const chords_1 = require("./chords");
const branch_region_1 = require("./branch-region");
const { chord, point, or } = branch_region_1.operators;
describe('BranchRegion', () => {
    const quintary = fractions_1.Fractions.parseFactory(5);
    const pointA = quintary('_003');
    const pointB = quintary('_033');
    const pointC = quintary('1_330');
    const pointD = quintary('_200');
    const pointE = quintary('3_002');
    const pointF = quintary('_303');
    const pointG = quintary('_330');
    const pointH = quintary('4_303');
    const chordA = chords_1.Chords.create(pointA, pointF);
    const chordB = chords_1.Chords.create(pointB, pointC);
    const chordC = chords_1.Chords.create(pointD, pointE);
    const chordD = chords_1.Chords.create(pointG, pointH);
    it('supports simple branch regions', () => {
        const branchB = branch_region_1.BranchRegion.new(or(chord(chordB), point(pointC)));
        expect(branchB.contains(pointB)).toBe(false);
        expect(branchB.contains(pointC)).toBe(true);
        expect(branchB.contains(quintary('_034'))).toBe(true);
        expect(branchB.contains(pointD)).toBe(false);
    });
    it('defines nested regions', () => {
        const childBranch = branch_region_1.BranchRegion.simple(chordD, pointH);
        const parentBranch = branch_region_1.BranchRegion.simple(chordA, pointA)
            .without(childBranch);
        expect(childBranch.contains(quintary('_331'))).toBe(true);
        expect(childBranch.contains(pointG)).toBe(false);
        expect(childBranch.contains(pointH)).toBe(true);
        expect(childBranch.contains(pointA)).toBe(false);
        expect(childBranch.contains(pointB)).toBe(false);
        expect(parentBranch.contains(quintary('_331'))).toBe(false);
        expect(parentBranch.contains(pointG)).toBe(true);
        expect(parentBranch.contains(pointH)).toBe(false);
        expect(parentBranch.contains(pointA)).toBe(true);
        expect(parentBranch.contains(pointB)).toBe(false);
    });
});
//# sourceMappingURL=branch-region.spec.js.map
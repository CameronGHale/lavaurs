"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fractions_1 = require("./fractions");
const chords_1 = require("./chords");
const polygons_1 = require("./polygons");
const lamination_1 = require("./lamination");
const branch_region_1 = require("./branch-region");
const immutable_1 = require("immutable");
const binary = fractions_1.Fractions.parseFactory(2);
const ternary = fractions_1.Fractions.parseFactory(3);
const displayPoint = (t) => fractions_1.Fractions.toRational(t).join('/');
const displayPolygon = (poly) => {
    return poly.points.map(displayPoint).join(', ');
};
const newPolygon = (points) => polygons_1.Polygons.create(immutable_1.List(points));
describe('PullbackLamination', () => {
    test('pullBack and mapForward are inverses', () => {
        const criticalChord = chords_1.Chords.create(binary("_001"), // 1/7
        binary("1_010") // 9/14
        );
        const firstRegion = branch_region_1.BranchRegion.simple(criticalChord, criticalChord.lower);
        const secondRegion = firstRegion.complement();
        const branches = [
            firstRegion,
            secondRegion,
        ];
        const startingTriangle = newPolygon([
            binary("_001"),
            binary("_010"),
            binary("_100"),
        ]);
        let previousPullback = [startingTriangle];
        for (let i = 0; i < 5; i++) {
            const newPullback = lamination_1.Laminations.pullBack((_, b) => b)(previousPullback, branches);
            const mappedForward = lamination_1.Laminations.mapForward(polygons_1.Polygons.mapForward)(newPullback);
            expect(mappedForward.map(displayPolygon)).toEqual(previousPullback.map(displayPolygon));
            previousPullback = newPullback;
        }
    });
    test('binary rabbit lamination', () => {
        const criticalChord = chords_1.Chords.create(binary("_001"), // 1/7
        binary("1_010") // 9/14
        );
        const firstRegion = branch_region_1.BranchRegion.simple(criticalChord, criticalChord.lower);
        const secondRegion = firstRegion.complement();
        const branches = [
            firstRegion,
            secondRegion,
        ];
        const startingTriangle = newPolygon([
            binary("_001"),
            binary("_010"),
            binary("_100"),
        ]);
        const laminations = [];
        const pullbackGenerator = lamination_1.Laminations.iterates([startingTriangle], branches);
        for (let i = 0; i < 3; i++) {
            const leaves = pullbackGenerator.next().value;
            laminations.push(leaves.map(displayPolygon));
        }
        expect(laminations).toEqual([
            ['1/7, 2/7, 4/7'],
            [
                '1/7, 2/7, 4/7',
                '1/14, 9/14, 11/14'
            ],
            [
                '1/7, 2/7, 4/7',
                '1/14, 9/14, 11/14',
                '9/28, 11/28, 15/28',
                '1/28, 23/28, 25/28'
            ]
        ]);
    });
    test('ternary symmetric lamination', () => {
        const criticalA = chords_1.Chords.create(ternary("_01"), // 1/8
        ternary("2_10") // 19/24
        );
        const criticalB = chords_1.Chords.create(ternary("0_21"), // 7/24
        ternary("_12") // 5/8
        );
        const firstRegion = branch_region_1.BranchRegion.simple(criticalA, criticalA.lower);
        const secondRegion = branch_region_1.BranchRegion.simple(criticalB, criticalB.upper);
        const thirdRegion = branch_region_1.BranchRegion.complement(firstRegion, secondRegion);
        const branches = [
            firstRegion,
            secondRegion,
            thirdRegion
        ];
        const firstLeaves = [
            chords_1.Chords.create(ternary("_01"), // 1/8
            ternary("_21") // 7/8
            ),
            chords_1.Chords.create(ternary("_10"), // 3/8
            ternary("_12") // 5/8
            )
        ].map(polygons_1.Polygons.fromChord);
        const laminations = [];
        const pullbackGenerator = lamination_1.Laminations.iterates(firstLeaves, branches);
        for (let i = 0; i < 2; i++) {
            const leaves = pullbackGenerator.next().value;
            laminations.push(leaves.map(displayPolygon));
        }
        expect(laminations).toEqual([
            [
                '1/8, 7/8',
                '3/8, 5/8'
            ],
            [
                '1/24, 23/24',
                '3/8, 5/8',
                '7/24, 17/24',
                '1/8, 7/8',
                '11/24, 13/24',
                '5/24, 19/24'
            ]
        ]);
    });
});
//# sourceMappingURL=lamination.spec.js.map
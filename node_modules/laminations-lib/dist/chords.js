"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fractions_1 = require("./fractions");
const util_1 = require("./util");
const create = (a, b) => {
    if (fractions_1.Fractions.greaterThan(a, b)) {
        return util_1.withCachedToString(toString, {
            lower: b,
            upper: a,
        });
    }
    return util_1.withCachedToString(toString, {
        lower: a,
        upper: b,
    });
};
const mapForward = (chord) => create(fractions_1.Fractions.mapForward(chord.lower), fractions_1.Fractions.mapForward(chord.upper));
const onBoundary = (chord, point) => {
    return fractions_1.Fractions.equals(chord.lower, point) || fractions_1.Fractions.equals(chord.upper, point);
};
const intersects = (a, b) => {
    const containsFirstButNotSecond = (first, second) => inInnerRegion(a, first) && inOuterRegion(a, second);
    return containsFirstButNotSecond(b.lower, b.upper)
        || containsFirstButNotSecond(b.upper, b.lower);
};
const inInnerRegion = (chord, point) => {
    return fractions_1.Fractions.greaterThan(point, chord.lower) && fractions_1.Fractions.lessThan(point, chord.upper);
};
const inOuterRegion = (chord, point) => {
    return !(inInnerRegion(chord, point) || onBoundary(chord, point));
};
const contains = (chord, point, flip = false) => {
    if (util_1.xor(width(chord) > 0.5, flip)) {
        return inOuterRegion(chord, point);
    }
    return inInnerRegion(chord, point);
};
const width = (chord) => {
    const upperNum = fractions_1.Fractions.numerator(chord.upper);
    const upperDenom = fractions_1.Fractions.denominator(chord.upper);
    const lowerNum = fractions_1.Fractions.numerator(chord.lower);
    const lowerDenom = fractions_1.Fractions.denominator(chord.lower);
    return (upperNum * lowerDenom - lowerNum * upperDenom) / (upperDenom * lowerDenom);
};
const isDiameter = (chord) => {
    const upperNum = fractions_1.Fractions.numerator(chord.upper);
    const upperDenom = fractions_1.Fractions.denominator(chord.upper);
    const lowerNum = fractions_1.Fractions.numerator(chord.lower);
    const lowerDenom = fractions_1.Fractions.denominator(chord.lower);
    // this.upper >= this.lower implies that the difference below is positive.
    return 2 * (upperNum * lowerDenom - lowerNum * upperDenom) === upperDenom * lowerDenom;
};
const toString = (chord) => `${chord.lower}, ${chord.upper}`;
exports.Chords = {
    create,
    mapForward,
    onBoundary,
    intersects,
    inInnerRegion,
    inOuterRegion,
    contains,
    width,
    isDiameter,
    toString,
};
//# sourceMappingURL=chords.js.map
import { Fraction } from './fractions';
import { Chord } from './chords';
declare type Identifier = (NaryFraction: any) => boolean;
declare type MappingFunc = (Identifier: any) => Identifier;
export declare class BranchRegion {
    private identifier;
    constructor(identifier: Identifier);
    static new(identifier: Identifier): BranchRegion;
    static simple(c: Chord, ...points: Fraction[]): BranchRegion;
    static simple_flipped(c: Chord, ...points: Fraction[]): BranchRegion;
    static complement(...branches: BranchRegion[]): BranchRegion;
    contains(point: Fraction): boolean;
    containsChord(chord: Chord): boolean;
    unwrap(): Identifier;
    map(func: MappingFunc): BranchRegion;
    without(...branches: BranchRegion[]): BranchRegion;
    complement(): BranchRegion;
}
export declare const operators: {
    unit: typeof BranchRegion.new;
    or: (...identifiers: Identifier[]) => Identifier;
    and: (...identifiers: Identifier[]) => Identifier;
    not: (identifier: Identifier) => Identifier;
    none: (...identifiers: Identifier[]) => Identifier;
    point: (p: Fraction) => Identifier;
    chord: (c: Chord, flip?: boolean) => Identifier;
};
export {};

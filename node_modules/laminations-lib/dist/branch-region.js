"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fractions_1 = require("./fractions");
const chords_1 = require("./chords");
class BranchRegion {
    constructor(identifier) {
        this.identifier = identifier;
    }
    static new(identifier) {
        return new BranchRegion(identifier);
    }
    static simple(c, ...points) {
        return unit(or(chord(c), ...points.map(point)));
    }
    static simple_flipped(c, ...points) {
        return unit(or(chord(c, true), ...points.map(point)));
    }
    static complement(...branches) {
        return unit(none(...branches.map(b => b.unwrap())));
    }
    contains(point) {
        return this.identifier(point);
    }
    containsChord(chord) {
        return this.contains(chord.lower) && this.contains(chord.upper);
    }
    unwrap() {
        return this.identifier;
    }
    map(func) {
        return unit(func(this.identifier));
    }
    without(...branches) {
        return this.map(b => and(b, BranchRegion.complement(...branches).unwrap()));
    }
    complement() {
        return this.map(not);
    }
}
exports.BranchRegion = BranchRegion;
const unit = BranchRegion.new;
const or = (...identifiers) => {
    return (point) => identifiers.some(identifier => identifier(point));
};
const and = (...identifiers) => {
    return (point) => identifiers.every(identifier => identifier(point));
};
const not = (identifier) => {
    return (point) => !identifier(point);
};
const none = (...identifiers) => {
    return not(or(...identifiers));
};
const point = (p) => {
    return (candidate) => fractions_1.Fractions.equals(p, candidate);
};
const chord = (c, flip = false) => {
    return (point) => chords_1.Chords.contains(c, point, flip);
};
exports.operators = {
    unit,
    or,
    and,
    not,
    none,
    point,
    chord,
};
//# sourceMappingURL=branch-region.js.map
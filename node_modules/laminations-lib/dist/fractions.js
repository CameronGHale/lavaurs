"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const immutable_1 = require("immutable");
const util_1 = require("./util");
const create = (base, exactPart, repeatingPart) => {
    let [newExact, newRepeating] = simplify(exactPart, repeatingPart);
    if (newRepeating.size === 1 && newRepeating.first() === base - 1) {
        newRepeating = immutable_1.List();
        newExact = incrementDigitSequence(base, newExact);
    }
    if (newRepeating.size === 1 && newRepeating.first() === 0) {
        newRepeating = immutable_1.List();
    }
    if (newRepeating.size === 0) {
        newExact = removeTrailingZeroes(newExact);
    }
    return util_1.withCachedToString(toString, {
        base,
        exactPart: newExact,
        repeatingPart: newRepeating,
    });
};
const fromArrays = (base, exactPart, repeatingPart) => create(base, immutable_1.List(exactPart), immutable_1.List(repeatingPart));
const fromArraysFactory = (base) => (exactPart, repeatingPart) => fromArrays(base, exactPart, repeatingPart);
const simplify = (exactPart, repeatingPart) => {
    repeatingPart = reduceCircularSequence(repeatingPart);
    const repeatingSuffixStart = findCircularRepeatingSuffix(exactPart, repeatingPart);
    const newExactPart = exactPart.slice(0, repeatingSuffixStart);
    const repeatingSuffixLen = exactPart.size - repeatingSuffixStart;
    const newRepeatingPart = util_1.rotateRight(repeatingPart, repeatingSuffixLen % repeatingPart.size);
    return [newExactPart, newRepeatingPart];
};
const parse = (base, text) => {
    let [exactText, repeatingText] = text.split('_');
    if (repeatingText == null) {
        repeatingText = '';
    }
    const digitSplitter = base < 10 ? '' : ',';
    const exactPart = immutable_1.List(exactText.split(digitSplitter))
        .filter(str => str.length > 0)
        .map(x => parseInt(x));
    const repeatingPart = immutable_1.List(repeatingText.split(digitSplitter))
        .filter(str => str.length > 0)
        .map(x => parseInt(x));
    return create(base, exactPart, repeatingPart);
};
const parseFactory = (base) => (text) => parse(base, text);
const mapForward = (fraction) => create(fraction.base, fraction.exactPart.slice(1), util_1.rotateLeft(fraction.repeatingPart, fraction.exactPart.size > 0 ? 0 : 1));
const mapBackward = (fraction) => immutable_1.Range(0, fraction.base).map(newDigit => create(fraction.base, fraction.exactPart.unshift(newDigit), fraction.repeatingPart)).toList();
const compare = (a, b) => {
    if (equals(a, b)) {
        return 0;
    }
    if (lessThan(a, b)) {
        return -1;
    }
    return 1;
};
const equals = (a, b) => {
    if (a.base !== b.base) {
        const [aNum, aDenom] = toRational(a);
        const [bNum, bDenom] = toRational(b);
        return aNum === bNum && aDenom === bDenom;
    }
    return a.exactPart.equals(b.exactPart) && a.repeatingPart.equals(b.repeatingPart);
};
const lessThan = (a, b) => {
    if (a.base !== b.base) {
        return equals(a, b) === false && toNumber(a) < toNumber(b);
    }
    const approxLen = (frac) => frac.exactPart.size + frac.repeatingPart.size;
    const upperBound = 2 * Math.max(approxLen(a), approxLen(b));
    for (let idx = 0; idx < upperBound; idx++) {
        const thisDigit = digitAt(a, idx);
        const otherDigit = digitAt(b, idx);
        if (thisDigit === otherDigit) {
            continue;
        }
        return thisDigit < otherDigit;
    }
    return false;
};
const greaterThan = (a, b) => {
    return compare(a, b) === 1;
};
const digitAt = (fraction, idx) => {
    const exactLen = fraction.exactPart.size;
    const repeatingLen = fraction.repeatingPart.size;
    if (idx < exactLen) {
        return fraction.exactPart.get(idx);
    }
    if (repeatingLen === 0) {
        return 0;
    }
    return fraction.repeatingPart.get((idx - exactLen) % repeatingLen);
};
const toNumber = (fraction) => {
    return numerator(fraction) / denominator(fraction);
};
const toRational = (fraction) => {
    const num = numerator(fraction);
    const denom = denominator(fraction);
    const gcd = util_1.greatestCommonDivisor(num, denom) | 0;
    return [(num / gcd) | 0, (denom / gcd) | 0];
};
const numerator = (fraction) => {
    const d = fraction.base;
    return repeatingDenominator(fraction) * valueFromDigits(d, fraction.exactPart)
        + valueFromDigits(d, fraction.repeatingPart);
};
const denominator = (fraction) => {
    return repeatingDenominator(fraction) * util_1.integer_pow(fraction.base, fraction.exactPart.size);
};
const repeatingDenominator = (fraction) => {
    const result = util_1.integer_pow(fraction.base, fraction.repeatingPart.size) - 1;
    if (result === 0) {
        return 1;
    }
    return result;
};
const toString = (fraction) => {
    const joiner = fraction.base < 10 ? '' : ',';
    return `${fraction.exactPart.join(joiner)}_${fraction.repeatingPart.join(joiner)}`;
};
/**
 * Finds the shortest-length contiguous subsequence w of 'sequence' such that
 * 'sequence' is some number of concatenations of w.
 * Ex:
 * [1, 1, 1] -> [1]
 * [1, 2, 3, 1, 2, 3] -> [1, 2, 3]
 * [1, 2, 3, 1, 2] -> [1, 2, 3, 1, 2]
 */
const reduceCircularSequence = (sequence) => {
    if (sequence.size === 0) {
        return sequence;
    }
    let prefix_table = makeKMPFailureTable(immutable_1.List(sequence));
    let candidate_length = findNaturalSuffixStart(prefix_table); // exclusive
    if (sequence.size % candidate_length === 0) {
        return sequence.slice(0, candidate_length);
    }
    return sequence;
};
const makeKMPFailureTable = (sequence) => {
    // This is the failure function from the KMP algorithm.
    // table[i] is the length of the longest proper prefix of
    // sequence that is also a suffix of needle (up to i).
    return immutable_1.Repeat(0, sequence.size).toList().withMutations(table => {
        let prefixEnd = 0; // exclusive
        let cursor = 1;
        // Key observation: a prefix/suffix match at i, j and a character
        // match at i+1, j+1 implies a prefix/suffix match at i+1/j+1.
        while (cursor < sequence.size) {
            const item = sequence.get(cursor);
            if (item == sequence.get(prefixEnd)) {
                // The order here matters. It could be written as
                // table[cursor++] = ++prefix_end, 
                // if one is spiteful of future readers.
                prefixEnd++;
                table.set(cursor, prefixEnd);
                cursor++;
                continue;
            }
            if (prefixEnd === 0) {
                table.set(cursor, 0);
                cursor++;
                continue;
            }
            // 'Recursive' step: retry against the longest prefix/suffix
            // of the current prefix. Recall that the prefix described by
            // `prefix_end` is exclusive, so the last index of the prefix
            // is at (prefix_end - 1).
            prefixEnd = table.get(prefixEnd - 1);
        }
    });
};
// Finds the first index of a partial sequence of natural numbers.
// Ex: [1, 0, 1, 1, 2, 3, 4, 5] -> 3
// Ex: [1, 0, 1, 1] -> 3
// Ex: [1, 0, 1] -> 2
// Ex: [0, 2, 3, 2] -> 4
// Ex: [] -> 0
const findNaturalSuffixStart = (sequence) => {
    if (sequence.size === 0) {
        return 0;
    }
    const lastIndex = sequence.size - 1;
    const last = sequence.get(lastIndex);
    if (last <= 0) {
        return sequence.size;
    }
    for (let i = lastIndex; i > lastIndex - last; i--) {
        const target = last - (lastIndex - i);
        if (sequence.get(i) !== target) {
            break;
        }
        if (target === 1) {
            return i;
        }
    }
    return sequence.size;
};
/**
 * Finds the smallest index i such that sequence.slice(i) is a suffix of 'repeating' followed by
 * some number of concatenations of 'repeating'. Returns sequence.length if no such suffix exists.
 * Ex:
 * ([1], [0,2,1]) -> 0
 * ([3,1,1], [0,2,1]) -> 2
 * ([3,1,1,0,2,1], [0,2,1]) -> 2
 * ([3,1,1,0,2,1,0,2,1], [0,2,1]) -> 2
 * ([3], [0,2,1]) -> 1
 * ([3], []) -> 1
 * ([], []) -> 0
 */
const findCircularRepeatingSuffix = (sequence, repeating) => {
    const indexSequenceFromRight = idx => sequence.size - idx - 1;
    const indexRepeatingFromRight = idx => repeating.size - (idx % repeating.size) - 1;
    for (let cursor = 0; cursor < sequence.size; cursor++) {
        const sequenceIdx = indexSequenceFromRight(cursor);
        const repeatingIdx = indexRepeatingFromRight(cursor);
        if (sequence.get(sequenceIdx) !== repeating.get(repeatingIdx)) {
            return sequenceIdx + 1;
        }
    }
    return 0;
};
const valueFromDigits = (base, digits) => {
    let sum = 0;
    let place = 1;
    for (let idx = digits.size - 1; idx >= 0; idx--) {
        sum += digits.get(idx) * place;
        place *= base;
    }
    return sum | 0;
};
const incrementDigitSequence = (base, digits) => {
    return digits.withMutations(copy => {
        let carry = 1;
        let idx = digits.size - 1;
        while (idx >= 0 && carry !== 0) {
            copy.update(idx, x => x + 1);
            carry--;
            if (copy.get(idx) === base) {
                copy.set(idx, 0);
                carry++;
            }
            idx--;
        }
    });
};
const removeTrailingZeroes = (numbers) => {
    let idx = numbers.size - 1;
    while (idx >= 0 && numbers.get(idx) === 0) {
        idx--;
    }
    return numbers.slice(0, idx + 1);
};
exports.Fractions = {
    create,
    fromArrays,
    fromArraysFactory,
    simplify,
    parse,
    parseFactory,
    mapForward,
    mapBackward,
    compare,
    equals,
    lessThan,
    greaterThan,
    digitAt,
    toNumber,
    toRational,
    numerator,
    denominator,
    repeatingDenominator,
    toString,
    reduceCircularSequence,
    makeKMPFailureTable,
    findNaturalSuffixStart,
    findCircularRepeatingSuffix,
    valueFromDigits,
    incrementDigitSequence,
    removeTrailingZeroes,
};
//# sourceMappingURL=fractions.js.map
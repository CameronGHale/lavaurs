import { List } from 'immutable';
/**
 * A module for manipulating fractions on the interval [0, 1) represented as a sequence of exact
 * digits followed by a sequence of repeating digits.
 * For example:
 * - In base 3 (ternary), 0.1 (one third) would be represented by
 *   `parse(3, "1_")`
 * - In base 2 (binary), 0.101101101... (five sevenths) would be represented by
 *   `parse(2, "_101")` and 0.1_101101101... (twelve fourteenths)
 *   would be represented by `parse(2, "1_101")`
 */
export interface Fraction {
    base: number;
    exactPart: List<number>;
    repeatingPart: List<number>;
}
declare type Rational = [number, number];
export declare const Fractions: {
    create: (base: number, exactPart: List<number>, repeatingPart: List<number>) => Fraction;
    fromArrays: (base: number, exactPart: number[], repeatingPart: number[]) => Fraction;
    fromArraysFactory: (base: number) => (exactPart: number[], repeatingPart: number[]) => Fraction;
    simplify: (exactPart: List<number>, repeatingPart: List<number>) => [List<number>, List<number>];
    parse: (base: number, text: string) => Fraction;
    parseFactory: (base: number) => (text: string) => Fraction;
    mapForward: (fraction: Fraction) => Fraction;
    mapBackward: (fraction: Fraction) => List<Fraction>;
    compare: (a: Fraction, b: Fraction) => number;
    equals: (a: Fraction, b: Fraction) => boolean;
    lessThan: (a: Fraction, b: Fraction) => boolean;
    greaterThan: (a: Fraction, b: Fraction) => boolean;
    digitAt: (fraction: Fraction, idx: number) => number;
    toNumber: (fraction: Fraction) => number;
    toRational: (fraction: Fraction) => Rational;
    numerator: (fraction: Fraction) => number;
    denominator: (fraction: Fraction) => number;
    repeatingDenominator: (fraction: Fraction) => number;
    toString: (fraction: Fraction) => string;
    reduceCircularSequence: <T>(sequence: List<T>) => List<T>;
    makeKMPFailureTable: <T_1>(sequence: List<T_1>) => List<number>;
    findNaturalSuffixStart: (sequence: List<number>) => number;
    findCircularRepeatingSuffix: <T_2>(sequence: List<T_2>, repeating: List<T_2>) => number;
    valueFromDigits: (base: number, digits: List<number>) => number;
    incrementDigitSequence: (base: number, digits: List<number>) => List<number>;
    removeTrailingZeroes: (numbers: List<number>) => List<number>;
};
export {};

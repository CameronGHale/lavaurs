"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const branch_region_1 = require("./branch-region");
exports.makeBranchSpec = (chord, ...endpoints) => ({ chord, endpoints });
class TreeNode {
    constructor(branchSpec) {
        this.branchSpec = branchSpec;
        this.region = this.createRegion(branchSpec);
        this.children = new Set();
    }
    static new(branchSpec) {
        return new TreeNode(branchSpec);
    }
    getChildren() {
        return [...this.children.values()];
    }
    addChild(node) {
        for (let child of this.children) {
            if (child.contains(node)) {
                return child.addChild(node);
            }
            if (node.contains(child)) {
                this.children.delete(child);
                node.addChild(child);
                this.children.add(node);
            }
        }
        this.children.add(node);
    }
    contains(other) {
        return this.region.containsChord(other.branchSpec.chord);
    }
    *postOrder() {
        for (let child of this.children) {
            yield* child.postOrder();
        }
        yield this;
    }
    createRegion(branchSpec) {
        if (branchSpec.flip === true) {
            return branch_region_1.BranchRegion.simple_flipped(branchSpec.chord, ...branchSpec.endpoints);
        }
        return branch_region_1.BranchRegion.simple(branchSpec.chord, ...branchSpec.endpoints);
    }
}
exports.buildBranches = (specs) => {
    const forestSet = specs.map(TreeNode.new)
        .reduce((nodes, newNode) => {
        for (let node of nodes.values()) {
            if (node.contains(newNode)) {
                node.addChild(newNode);
                return nodes;
            }
            if (newNode.contains(node)) {
                nodes.delete(node);
                newNode.addChild(node);
                nodes.add(newNode);
            }
        }
        nodes.add(newNode);
        return nodes;
    }, new Set());
    const rootNodes = [...forestSet.values()];
    return rootNodes.map((root) => {
        const result = [];
        for (let node of root.postOrder()) {
            const region = node.region.without(...node.getChildren().map(n => n.region));
            result.push(region);
        }
        return result;
    }).reduce((arr1, arr2) => arr1.concat(arr2));
};
exports.maybeAddFinalBranch = (base, regions) => {
    if (regions.length === base) {
        return regions;
    }
    const finalRegion = branch_region_1.BranchRegion.complement(...regions);
    return [...regions, finalRegion];
};
exports.makeBuilder = (base) => (specs) => {
    return exports.maybeAddFinalBranch(base, exports.buildBranches(specs));
};
//# sourceMappingURL=branch-builder.js.map